<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playable Chess Game</title>
    <style>
        /* General Styling */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #1a1a2e;
            color: #fff;
            margin: 0;
            padding: 20px;
        }

        .container {
            background-color: #2c2c54;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            width: 500px;
        }

        h1 {
            text-align: center;
            color: #ffcc00;
            margin-bottom: 20px;
            font-size: 1.8rem;
        }

        /* Status and Controls */
        #status-bar {
            text-align: center;
            font-size: 1.2rem;
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 8px;
            background-color: #3f3f78;
            border: 2px solid #5a5a8a;
            font-weight: bold;
        }

        #reset-btn {
            display: block;
            width: 100%;
            padding: 12px;
            margin-top: 20px;
            background-color: #e94560;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.1s;
            box-shadow: 0 4px #c8354c;
        }

        #reset-btn:hover {
            background-color: #c8354c;
        }

        #reset-btn:active {
            transform: translateY(2px);
            box-shadow: 0 2px #c8354c;
        }

        /* Chess Board Grid */
        #chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            aspect-ratio: 1 / 1; /* Ensures it's always square */
            border: 4px solid #1a1a2e;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: min(8vw, 40px); /* Responsive font size */
            cursor: pointer;
            user-select: none;
            transition: background-color 0.1s;
        }

        /* Square Colors */
        .light {
            background-color: #f0d9b5; /* Light wood */
        }

        .dark {
            background-color: #b58863; /* Dark wood */
        }

        /* Piece Colors (for emojis) */
        .piece-white {
            color: #fff;
            text-shadow: 1px 1px 2px #000000;
        }

        .piece-black {
            color: #000;
            text-shadow: 1px 1px 2px #fff;
        }

        /* Interaction States */
        .selected {
            background-color: #79a6d2 !important; /* Blue selection */
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .valid-move {
            background-color: #90ee90; /* Light green highlight for moves */
            border: 3px solid #006400;
        }

        .valid-move.dark {
             background-color: #61b161;
        }

        .checked {
            animation: pulse-check 1s infinite alternate;
            background-color: #ff6347 !important; /* Tomato red if King is checked */
        }

        @keyframes pulse-check {
            from { box-shadow: 0 0 10px 5px #ff6347; }
            to { box-shadow: 0 0 20px 8px #ff0000; }
        }

    </style>
</head>
<body>

    <div class="container">
        <h1>Single-Player Chess</h1>
        <div id="status-bar">White's Turn</div>
        <div id="chessboard">
            <!-- Squares will be generated by JavaScript here -->
        </div>
        <button id="reset-btn">Reset Game</button>
    </div>

    <script>
        // Global state and constants
        const boardEl = document.getElementById('chessboard');
        const statusEl = document.getElementById('status-bar');
        const resetBtn = document.getElementById('reset-btn');

        // Piece definitions: {piece_code: {emoji, color, value}}
        // Capital = White, Lowercase = Black
        const PIECES = {
            'K': { emoji: '♔', color: 'white', value: 1000 },
            'Q': { emoji: '♕', color: 'white', value: 9 },
            'R': { emoji: '♖', color: 'white', value: 5 },
            'B': { emoji: '♗', color: 'white', value: 3 },
            'N': { emoji: '♘', color: 'white', value: 3 },
            'P': { emoji: '♙', color: 'white', value: 1 },
            'k': { emoji: '♚', color: 'black', value: 1000 },
            'q': { emoji: '♛', color: 'black', value: 9 },
            'r': { emoji: '♜', color: 'black', value: 5 },
            'b': { emoji: '♝', color: 'black', value: 3 },
            'n': { emoji: '♞', color: 'black', value: 3 },
            'p': { emoji: '♟', color: 'black', value: 1 },
            '': { emoji: '', color: null, value: 0 } // Empty square
        };

        // Game State Variables
        let board = [];
        let currentPlayer = 'white'; // 'white' or 'black'
        let selectedSquare = null; // {row, col} of the selected piece
        let isGameOver = false;

        // --- Helper Functions ---

        /**
         * Converts row/col to algebraic notation (e.g., 7, 0 -> a1)
         * @param {number} r Row index (0-7)
         * @param {number} c Column index (0-7)
         * @returns {string} Algebraic notation
         */
        function toAlgebraic(r, c) {
            const col = String.fromCharCode('a'.charCodeAt(0) + c);
            const row = 8 - r;
            return col + row;
        }

        /**
         * Gets the color of a piece code.
         * @param {string} pieceCode 'P', 'k', '' etc.
         * @returns {'white'|'black'|null}
         */
        function getPieceColor(pieceCode) {
            if (!pieceCode) return null;
            return pieceCode === pieceCode.toUpperCase() ? 'white' : 'black';
        }

        /**
         * Initializes the board with the starting chess positions.
         */
        function initializeBoard() {
            isGameOver = false;
            currentPlayer = 'white';
            selectedSquare = null;

            // FEN for starting position: r n b q k b n r / p p p p p p p p / 8 / 8 / 8 / 8 / P P P P P P P P / R N B Q K B N R
            const setup = [
                ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
            ];
            board = setup;
        }

        /**
         * Renders the current state of the board to the HTML.
         */
        function drawBoard() {
            boardEl.innerHTML = ''; // Clear board
            let kingSquare = null;

            // Find the current player's King
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece.toLowerCase() === 'k' && getPieceColor(piece) === currentPlayer) {
                        kingSquare = { r, c };
                        break;
                    }
                }
                if (kingSquare) break;
            }

            // Draw squares
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const pieceCode = board[r][c];
                    const piece = PIECES[pieceCode];
                    const squareEl = document.createElement('div');
                    squareEl.classList.add('square');
                    squareEl.dataset.row = r;
                    squareEl.dataset.col = c;

                    // Set square color (alternating light/dark)
                    const colorClass = (r + c) % 2 === 0 ? 'light' : 'dark';
                    squareEl.classList.add(colorClass);

                    // Set piece content and color
                    if (pieceCode) {
                        squareEl.innerHTML = piece.emoji;
                        squareEl.classList.add(`piece-${piece.color}`);
                    }

                    // Highlight selected square
                    if (selectedSquare && selectedSquare.r === r && selectedSquare.c === c) {
                        squareEl.classList.add('selected');
                    }

                    // Highlight King if in Check (simplified check detection)
                    if (kingSquare && kingSquare.r === r && kingSquare.c === c) {
                        if (isSquareAttacked(r, c, currentPlayer === 'white' ? 'black' : 'white')) {
                             squareEl.classList.add('checked');
                             statusEl.textContent = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)} is in Check!`;
                        }
                    }

                    // Mark valid move targets
                    if (selectedSquare) {
                        const validMoves = getValidMoves(selectedSquare.r, selectedSquare.c);
                        if (validMoves.some(move => move.r === r && move.c === c)) {
                            squareEl.classList.add('valid-move');
                        }
                    }

                    squareEl.addEventListener('click', () => handleSquareClick(r, c));
                    boardEl.appendChild(squareEl);
                }
            }

            // Update status bar text if not in check
            if (!document.querySelector('.checked')) {
                const turn = currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1);
                statusEl.textContent = `${turn}'s Turn`;
                if(isGameOver) statusEl.textContent = `Game Over! ${turn} wins!`; // This is basic, true checkmate detection is too complex for this example.
            }
        }

        // --- Movement Validation Logic (Simplified) ---

        /**
         * Checks if a move is within board bounds and not a null move.
         */
        function isValidTarget(r1, c1, r2, c2) {
            return r2 >= 0 && r2 < 8 && c2 >= 0 && c2 < 8 && !(r1 === r2 && c1 === c2);
        }

        /**
         * Checks if a path is clear between two squares (for R, B, Q).
         */
        function isPathClear(r1, c1, r2, c2) {
            const dr = Math.sign(r2 - r1);
            const dc = Math.sign(c2 - c1);
            let r = r1 + dr;
            let c = c1 + dc;

            while (r !== r2 || c !== c2) {
                if (board[r][c] !== '') {
                    return false; // Path blocked
                }
                r += dr;
                c += dc;
            }
            return true; // Path clear
        }

        /**
         * Validates a move for a specific piece.
         * Note: This is simplified and does NOT check for resulting checks/checkmates.
         * @param {number} r1 Start row
         * @param {number} c1 Start column
         * @param {number} r2 Target row
         * @param {number} c2 Target column
         * @returns {boolean} True if the move is physically valid for the piece type.
         */
        function validateMove(r1, c1, r2, c2) {
            if (!isValidTarget(r1, c1, r2, c2)) return false;

            const pieceCode = board[r1][c1];
            const pieceType = pieceCode.toLowerCase();
            const targetPieceCode = board[r2][c2];
            const pieceColor = getPieceColor(pieceCode);
            const targetColor = getPieceColor(targetPieceCode);

            // Cannot capture your own piece
            if (targetColor === pieceColor) return false;

            const dr = Math.abs(r2 - r1);
            const dc = Math.abs(c2 - c1);

            switch (pieceType) {
                case 'p': // Pawn
                    const direction = (pieceColor === 'white') ? -1 : 1;
                    const isFirstMove = (pieceColor === 'white' && r1 === 6) || (pieceColor === 'black' && r1 === 1);

                    // Move forward 1 step
                    if (dc === 0 && r2 - r1 === direction && targetPieceCode === '') {
                        return true;
                    }
                    // Move forward 2 steps on first move
                    if (dc === 0 && r2 - r1 === 2 * direction && isFirstMove && targetPieceCode === '' && board[r1 + direction][c1] === '') {
                        return true;
                    }
                    // Capture diagonally 1 step
                    if (dc === 1 && r2 - r1 === direction && targetPieceCode !== '') {
                        return true;
                    }
                    return false;

                case 'r': // Rook
                    if ((dr === 0 && dc > 0) || (dc === 0 && dr > 0)) { // Straight lines
                        return isPathClear(r1, c1, r2, c2);
                    }
                    return false;

                case 'n': // Knight
                    // L-shape move
                    return (dr === 1 && dc === 2) || (dr === 2 && dc === 1);

                case 'b': // Bishop
                    if (dr === dc && dr > 0) { // Diagonal lines
                        return isPathClear(r1, c1, r2, c2);
                    }
                    return false;

                case 'q': // Queen
                    if ((dr === 0 || dc === 0) || (dr === dc)) { // Straight or diagonal
                        return isPathClear(r1, c1, r2, c2);
                    }
                    return false;

                case 'k': // King
                    // Can move one square in any direction
                    return dr <= 1 && dc <= 1;

                default:
                    return false;
            }
        }

        /**
         * Gets all physically valid moves for a piece at (r, c), including captures.
         * It also checks if the move puts the current player's King in check.
         * @param {number} r Row index
         * @param {number} c Column index
         * @returns {Array<{r: number, c: number}>} Array of valid target coordinates
         */
        function getValidMoves(r, c) {
            const pieceCode = board[r][c];
            const pieceColor = getPieceColor(pieceCode);
            if (pieceColor !== currentPlayer) return [];

            const validMoves = [];

            for (let r2 = 0; r2 < 8; r2++) {
                for (let c2 = 0; c2 < 8; c2++) {
                    if (validateMove(r, c, r2, c2)) {
                        // Check for check: A move is only valid if it doesn't leave or put your own King in check
                        if (!leavesKingInCheck(r, c, r2, c2)) {
                            validMoves.push({ r: r2, c: c2 });
                        }
                    }
                }
            }
            return validMoves;
        }


        // --- Check Detection (Crucial for Playability) ---

        /**
         * Checks if a given square (r, c) is currently under attack by the opposing player.
         * @param {number} r Target row
         * @param {number} c Target column
         * @param {'white'|'black'} attackingColor The color that is attacking the square
         * @returns {boolean} True if the square is attacked
         */
        function isSquareAttacked(r, c, attackingColor) {
            for (let r1 = 0; r1 < 8; r1++) {
                for (let c1 = 0; c1 < 8; c1++) {
                    const pieceCode = board[r1][c1];
                    if (getPieceColor(pieceCode) === attackingColor) {
                        // Temporarily bypass the 'targetColor === pieceColor' check in validateMove
                        // to correctly identify threats, then manually check if the target is empty or opponent's piece.
                        // Instead, we just check if the piece can physically reach the square (r, c) regardless of what's there.
                        // We must use a version of validateMove that ignores the target piece color/existence.

                        // A simpler way: temporarily make the target square empty and check validity
                        const originalTargetPiece = board[r][c];
                        board[r][c] = ''; // Pretend target is empty for threat analysis

                        let isAttacking = false;
                        if (validateMove(r1, c1, r, c)) {
                            isAttacking = true;
                        }

                        board[r][c] = originalTargetPiece; // Restore original piece
                        if (isAttacking) return true;
                    }
                }
            }
            return false;
        }

        /**
         * Checks if making a move (r1, c1) -> (r2, c2) leaves the current player's King in check.
         * @returns {boolean} True if the King is left in check
         */
        function leavesKingInCheck(r1, c1, r2, c2) {
            // 1. Simulate the move
            const originalPiece = board[r1][c1];
            const capturedPiece = board[r2][c2];
            board[r2][c2] = originalPiece;
            board[r1][c1] = '';

            // 2. Find the King's new position
            let kingR, kingC;
            const kingPieceCode = currentPlayer === 'white' ? 'K' : 'k';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] === kingPieceCode) {
                        kingR = r;
                        kingC = c;
                        break;
                    }
                }
            }

            // 3. Check if the King is attacked by the opponent after the move
            const opponentColor = currentPlayer === 'white' ? 'black' : 'white';
            const isInCheck = isSquareAttacked(kingR, kingC, opponentColor);

            // 4. Undo the move
            board[r1][c1] = originalPiece;
            board[r2][c2] = capturedPiece;

            return isInCheck;
        }


        // --- User Interaction Handler ---

        /**
         * Handles a click on a square.
         * @param {number} r Row index of clicked square
         * @param {number} c Column index of clicked square
         */
        function handleSquareClick(r, c) {
            if (isGameOver) return;

            const pieceCode = board[r][c];
            const pieceColor = getPieceColor(pieceCode);

            // 1. No piece selected yet, and a piece of the current player is clicked: Select it
            if (!selectedSquare && pieceColor === currentPlayer) {
                selectedSquare = { r, c };
            }
            // 2. A piece of the current player is already selected, and the same piece is clicked: Deselect it
            else if (selectedSquare && selectedSquare.r === r && selectedSquare.c === c) {
                selectedSquare = null;
            }
            // 3. A piece is selected, and a square is clicked: Attempt a move
            else if (selectedSquare) {
                const { r: r1, c: c1 } = selectedSquare;
                const r2 = r;
                const c2 = c;

                const validMoves = getValidMoves(r1, c1);
                const isTargetValid = validMoves.some(move => move.r === r2 && move.c === c2);

                if (isTargetValid) {
                    // Execute the move
                    board[r2][c2] = board[r1][c1];
                    board[r1][c1] = '';

                    // Check for pawn promotion (simplified: automatically promote to Queen)
                    if (board[r2][c2].toLowerCase() === 'p' && (r2 === 0 || r2 === 7)) {
                         const promotionPiece = currentPlayer === 'white' ? 'Q' : 'q';
                         board[r2][c2] = promotionPiece;
                    }

                    // Switch turn
                    currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
                    selectedSquare = null;

                } else {
                    // Invalid move attempt
                    // If the click was on the current player's *other* piece, select the new piece instead
                    if (pieceColor === currentPlayer) {
                        selectedSquare = { r, c };
                    } else {
                        // Clicked an invalid move or opponent's piece; just deselect
                        selectedSquare = null;
                    }
                }
            }
            // 4. No piece selected, and an empty square or opponent's piece is clicked: Ignore
            else {
                // Do nothing
            }

            drawBoard(); // Redraw the board after any interaction
        }


        // --- Event Listeners and Initialization ---

        function startGame() {
            initializeBoard();
            drawBoard();
        }

        resetBtn.addEventListener('click', startGame);

        // Start the game when the script loads
        window.onload = startGame;

    </script>
</body>
</html>